# 디자인 패턴(Design Pattern)이란?
<!--Table of Contents-->
- 디자인 패턴의 정의
- 디자인 패턴의 분류
- 디자인 패턴 사용법
- 디자인 패턴을 고르는 방법



<!-- 어떤 질문을 대답할 수 있어야 하는지-->
## You can answer
- 디자인 패턴이란?


<!--Contents-->

---
## 디자인 패턴(Design Pattern)의 정의
디자인 패턴(Design Pattern)은 소프트웨어 공학에서 소프트웨어 디자인의 주어진 context 내에서 
자주 발생하는 문제에 대한 일반적이고 재사용 가능한, 추상화 된 솔루션이다. 즉 , 반복적으로 나타나는 다양한 상황에서 사용할 수 있는 문제를 해결하는 방법을 위한 설명 또는 템플릿이다.  
- ' 이름 ' 의 중요성 : <i>이름은 곧 개념을 정의한다. </i>   
  대기열(waiting lines)의 개념을 가지고 예를 들어보면 한 알고리즘 설계자가 엘레베이터 이동 알고리즘을 새로 만들었다고 가정하자  
  '대기열' 이라는 이름이 없다면 설계자는 동료들에게 알고리즘을 공유할 때 "엘레베이터에 타는 사람들이 누른 층을 순서대로 저장한 뒤, 먼저 입력한 순서대로 차례대로 방문하는 방법" 이라고 설명해야한다.  
  하지만 이 개념에 '대기열' 이라는 이름이 부여되어 있고 모두가 알고 있다면 "입력되는 층을 대기열로 저장해 이동하는 방법"이라고 간단히 설명할 수 있을 것이다. <br>
  디자인 패턴 역시 이렇게 자주 사용되는 개념에 이름을 정의한 것이다.<br> 
   

- 하나의 패턴에 반드시 들어가는 4가지 요소  
    패턴 이름 : 한 두 단어로 설계 문제와 해법을 서술함  
    문제 : 언제 패턴을 사용하는가를 서술하며 해결할 문제와 그 배경을 설명함  
    해법 : 설계를 구성하는 요소들과 그 요소들 간의 관계, 책임 그리고 협력 관계를 서술함  
    결과 :  디자인 패턴을 적용해서 얻는 결과와 장단점을 서술함
  
  
- 디자인 패턴의 대부분이 OOP 패러다임에 국한되어있다. 하지만 소프트웨어 공학적으로 디자인 패턴은 패러다임과 알고리즘과는 다르다.  
  어떤 패러다임으로 개발하든 문제상황은 일관되므로 패러다임과 동의어가 될수없다.  
  또 디자인 패턴은 다수의 구체적인 상황과 알고리즘이 아닌, 일반화 된 해결책이므로 알고리즘과도 다르다.  
  단지, 많은 디자인 패턴에 OOP가 포함되어있고 GoF(Gang of Four : 디자인 패턴에 대한 책을 쓴 4명의 저자들) 역시 OOP에 초점을 두고 있다.
디자인 패턴은 OOP 프로그래밍에서 발생하는 문제를 해결하기위한 일반적인 접근 방식이다.  
  

- 왜 사용하는가?   
  재사용성이 높아 개발 시간을 단축시키며 소프트웨어 구조파악에 용이하다.   
  불필요한 리소스의 낭비를 방지하며 유지보수를 쉽게하여 요구사항의 변화에 대한 빠른 대처를 할 수 있다.

## 디자인 패턴의 분류  
   디자인 패턴은 아래와 같이 목적에 따라 3가지로 분류할 수 있는데,  
   이들은 모두 클래스와 인스턴스에 관한 생성, 구조화, 행동과 관련이 있다.  
   또, 범위에 따라 2가지로 나눌 수 있는데 패턴을 주로 클래스에 적용하는지, 객체에 적용하는지를 구분하여 나눈다.

|&nbsp;|*Creational(생성) patterns*|*Behavioral(행동) patterns*|*Structural(구조) patterns*|
|:---:|:---:|:---:|:---:|
|*Class*|Factory Method|Interpreter|Adapter(class)|
|&nbsp;|&nbsp;|Template Method|&nbsp;|
|*Object*|Builder|Mediator|Adapter(object)|
|&nbsp;|Abstract Factory|Chain of Responsibility|Facade|
|&nbsp;|Singleton|Command|Protection Proxy|
|&nbsp;|Prototype|Visitor|Composite|
|&nbsp;|&nbsp;|Observer / Listener |Bridge|
|&nbsp;|&nbsp;|State|Decorator|
|&nbsp;|&nbsp;|Memento|Proxy|
|&nbsp;|&nbsp;|Iterator|Flyweight|
|&nbsp;|&nbsp;|Strategy|&nbsp;|

## 디자인 패턴 사용법
다음은 GoF 책에 적혀있는 디자인 패턴 사용법이다.  
단순한 가이드이므로 참고용으로 보고 패턴을 공부하면서 자신에게 맞는 방법을 개발하는 것을 추천한다.
    
    1. 개괄적으로 한번 패턴을 훑는다 
       : 패턴이 해당 문제에 적합한지를 따져보기 위해 적용(Applicability)와 결론(Consequences) 부분에 특별한 주의를 갖는다.
    
    2. 다시 되돌아가서 구조(structure), 구성요소(participant), 구성요소간 관계(collaborations)에 대해 숙지한다 
       : 패턴에 있는 클래스들과 객체들에 대해 이해하고 서로 어떤 관계가 있는지를 확인한다.
    
    3. 코드에서 패턴의 구체적인 예를 살펴보기 위해 예제 코드(Sample Code) 부분을 본다 
       : 코드에 대한 공부는 패턴이 어떻게 구현되지는지를 배우는데 도움이 된다.
    
    4. 어플리케이션 범주에서 의미있는 패턴 구성요소에 대한 이름을 선정한다 
       : 설계 패턴에 있는 구성요소들의 이름은 어플리케이션에 직접적으로 표현하기에 너무 추상적이다.
         그럼에도 불구하고, 어플리케이션에 나타나는 이름으로 구성요소의 이름을 적당히 사용하는 것은 쓸모있다. 
         이는 구현에서 패턴을 좀 더 명시적으로 만드는데 도움이 된다.
         예를 들어, 텍스트 결합 알고리즘에서 Strategy 패턴을 사용하는 경우, 클래스를 SimpleLayoutStrategy 혹은 TextLayoutStrategy라고 만들 수 있다.
    
    5. 클래스를 정의한다 
       : 클래스에 대한 인터페이스를 정의하고, 상속(혹은 구현) 관계를 맺고, 데이터와 객체 참조를 나타내는 인스턴스 변수를 정의한다.
         패턴이 영향을 미치고, 이에 따라 해당 클래스를 변경하는 어플리케이션 내의 기존 클래스들을 식별한다.
    
    6. 패턴에 있는 오퍼레이션에 대해 어플리케이션에 특화된 이름을 정의한다 
       : 오퍼레이션 이름 역시 보통 어플리케이션에 따라 달라진다. 각 오퍼레이션과 관련된 책임성(responsiblity)과 협업관계(collaboration)을 참조하여 사용한다. 
         또한, 네이밍 규칙(naming convention)에 따라 일관성을 유지한다. 
         예를 들어, Factory method임을 표시하도록 일관되게 "create-" 라는 접두어를 사용할 수도 있다.
    
    7. 패턴에 있는 책임성과 협업관계를 수행하는 오퍼레이션을 구현한다 
       : 구현(implementation) 부분은 구현에 대한 가이드로 힌트를 제공한다. 예제 코드에 있는 사례 역시 도움이 될 수 있다.
   
## 디자인 패턴을 고르는 방법

    1. 패턴이 어떻게 문제를 해결하는지 파악한다.
    2. 패턴의 의도 부분을 본다.
    3. 패턴들 간의 관련성을 파악한다.
    4. 비슷한 목적의 패턴들을 모아서 공부한다.
    5. 재설계의 원인을 파악한다.
    6. 설계에서 가변성을 가져야 하는 부분이 무엇인지 파악한다.
---
## Reference
- [SoftWare design pattern](https://en.wikipedia.org/wiki/Software_design_pattern#Behavioral_patterns)
- [GoF의 디자인 패턴(Summary)](https://scvgoe.github.io/2018-12-24-GoF%EC%9D%98-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-(Summary)-1/)
- [Design Pattern 사용법](https://homo-ware.tistory.com/106?category=64601)

