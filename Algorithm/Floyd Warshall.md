# 플로이드 워샬 (Floyd Warshall)
- 플로이드 워샬 알고리즘의 정의
- 플로이드 워샬 알고리즘 소스코드 (Python)
- 플로이드 워샬 알고리즘의 시간 복잡도


## You can answer
- 플로이드 워샬 알고리즘이 무엇인가?
- 플로이드 워샬 알고리즘의 시간 복잡도는 어떻게 되는가?
-----------------------

</br>


## 플로이드 워샬 알고리즘
- '모든 지점에서 다른 모든 지점까지의 최단 경로를 구해야 하는 경우'에 사용할 수 있는 알고리즘이다. </br>
다익스트라 알고리즘에서는 출발 노드가 1개이므로 다른 모든 노드까지의 최단 거리를 저장하기 위해서 1차원 리스트를 이용했다. 반면에 플로이드 워셜 알고리즘은 다익스트라 알고리즘과는 다르게 2차원 리스트에 '최단 거리' 정보를 저장한다는 특징이 있다.</br>
또한 다익스트라 알고리즘은 그리디 알고리즘인데 플로이드 워셜 알고리즘은 다이나믹 프로그래밍이라는 특징이 있다. 노드의 개수가 N이라고 할 때, N번 만큼의 단계를 반복하며 '점화식에 맞게' 2차원 리스트를 갱신하기 때문에 다이나믹 프로그래밍으로 볼 수 있다. 

</br>


## 플로이드 워샬 알고리즘 (Python)
```
#플로이드 워셜 알고리즘 소스코드
INF = int(1e9)
#노드의 개수 및 간선의 개수를 입력받기
n,m=map(int,input().split())
#2차원 리스트(그래프 표현)를 만들고, 모든 값을 무한으로 초기화
graph=[[INF]*(n+1) for _ in range(n+1)]
#자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
for a in range(1,n+1):
    for b in range(1,n+1):
        if a==b:
            graph[a][b]=0
#각 간선에 대한 정보를 입력받아, 그 값으로 초기화
for _ in range(m):
    #A에서 B로 가는 비용은 C라고 설정
    a,b,c=map(int,input().split())
    graph[a][b]=c
#점화식에 따라 플로이드 워셜 알고리즘을 수행
for k in range(1,n+1):
    for a in range(1,n+1):
        for b in range(1,n+1):
            graph[a][b]=min(graph[a][b],graph[a][k]+graph[k][b])
#수행된 결과를 출력
for a in range(1,n+1):
    for b in range(1,n+1):
        if graph[a][b]==INF:
            print("INFINITY",end=' ')
        else:
            print(graph[a][b],end=' ')
    #행 마다 줄바꿈 해준다 (1행하고 띄우고 2행하고 띄우고 ...)
    print()
            
```

</br>

## 플로이드 워샬 알고리즘의 시간 복잡도
- 전체 시간 복잡도는 O(N^3)이라고 할 수 있다.

<br/>

## Reference
- 이것이 취업을 위한 코딩 테스트다 with 파이썬 (나동빈 저자)