# 메모리 구조(Memory Structure)
- 프로그램 실행 순서
- 메모리 구조
    - code
    - data
    - stack
    - heap
- Stack vs Heap
- 오버플로우(Overflow)

## You can answer
- 메모리 구조
- Stack vs Heap 비교
- Stack, Heap Overflow?

---
# 프로그램 실행 순서

![1program](https://user-images.githubusercontent.com/22022393/116100838-44b0e800-a6e8-11eb-9beb-6354663e648a.png)


- 먼저 그림을 통해 프로그램이 실행되는 과정을 볼 수 있는데 이 때 OS는 메모리에 공간을 할당하는데 이는 4가지의 공간으로 볼 수 있다.


---

# 메모리 구조(Memory Structure)

![2memory](https://user-images.githubusercontent.com/22022393/116101220-9e191700-a6e8-11eb-88be-3f95ad1a83a5.png)


# 1. 코드(code) 영역
- 작성과 실행할 프로그램의 코드가 저장되는 영역이며 텍스트(text) 영역이라고도 부른다.
- 프로그램이 시작하고 끝날 때까지 메모리에 계속 남아 있으며 실행 파일을 구성하는 명령어들이 올라가는 메모리 영역으로 함수, 제어문, 상수 등이 지정된다.
- CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 된다.

# 2. 데이터(data) 영역
- 프로그램의 전역 변수와 정적(Static) 변수, 문자열 상수가 저장되는 영역.
- 프로그램이 시작할 때 할당되며 끝날 때까지 메모리에 계속 남아있다.

# 3. 스택(Stack) 영역
- 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역.
- 함수의 호출과 함께 할당되며 함수의 호출이 완료되면 소멸한다. 이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(Stack Frame)이라고 한다.
- 프로그램이 자동으로 사용하는 임시 메모리 영역이다.
- 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
- 컴파일 시에 크기가 결정된다.

장점 - 낭비되는 공간이 없고 하나의 명령만으로 메모리 조작과 어드레스 조작이 가능하다.
단점 - 한계가 있어 한계를 초과하도록 삽입할 수 없다. 즉, 유연성이 부족하다.

# 4. 힙(Heap) 영역
힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.
Java의 겨우 가비지 컬렉터가 자동으로 해제한다.
메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.
malloc() 또는 new 연산자를 통해 할당하고 free() 또는 delete 연산자를 통해서 해제가 가능하다.
런타임 시에 크기가 결정된다.
장점
프로그램에 필요한 개체의 개수나 크기를 미리 알 수 없는 경우에 사용 가능.
개체가 너무 커서 스택 할당자에 맞지 않는 경우 사용 가능.
단점
할당 작업으로 인한 속도 저하
해제 작업으로 인한 속도 저하
주로 병합을 사용할 때 해제 작업에 더 많은 주기가 소요된다.
힙 손상으로 인한 속도 저하

응용 프로그램에서 힙 블록을 적절하게 사용하지 않을 경우 힙이 손상된다.

가장 많이 발생할 수 있는 힙 손상 문제로는 이중 해제, 해제 후 블록 사용, 블록 경계를 벗어나 덮어쓰기 등이 있다.

힙 경합으로 인한 속도 저하

두 개 이상의 쓰레드에서 동시에 데이터에 액세스하려고 하면 경합이 발생하여 한 쪽 쓰레드의 작업이 완료되어야 다른 쪽 쓰레드의 작업이 진행될 수 있다.

이 문제는 현재 다중 프로세서 시스템에서 일어나는 문제 중 가장 큰 문제다.

경합은 일반적으로 쓰레드와 프로세스의 컨텍스트 스위칭을 가져온다. 컨텍스트 스위칭에도 리소스가 많이 소모되지만 프로세서 캐시에서 데이터가 손실되어 나중에 해당 쓰레드가 다시 살아날 때 이 데이터를 다시 작성하는 데에 리소스가 훨씬 많이 소모된다.---

---

# Stack vs Heap
Stack 영역이 클수록 Heap 영역이 작아지고 Heap 영역이 클수록 Stack 영역이 작아진다.

스택 할당 속도와 힙 할당 속도를 비교해보자.

결론부터 말하자면 스택이 훨씬 빠르다. 스택은 이미 할당 되어있는 공간을 사용하는 것이고 힙은 사용자가 따로 할당해서 사용하는 공간이다. 다만 스택은 공간이 매우 적기 때문에 모든 응용에서 스택을 사용할 수 는 없다.

좀 더 자세히 알아보면,

스택에서 할당의 의미는 이미 생성되어 있는 스택에 대해 포인터의 위치만 바꿔주는 단순한 CPU Instruction(덧셈과 뺄셈 연산, 일반적으로 단일 Instruction)이다.

반면 힙에서의 할당은 요청된 chunk의 크기, 현재 메모리의 fragmentation 상황 등 다양한 요소를 고려하기 때무에 더 많은 CPU Instruction이 필요하다.

---

# 오버플로우(Overflow)

Stack의 지역변수는 사용되고 소멸하기 때문에 데이터 용량의 불확실성을 가진다. 따라서 Stack 영역에서의 주소값은 밑에서부터 채워지며 그 다음 주소는 선언된 순서대로 정해진다. 반면 Heap 영역에서의 주소값은 위에서부터 채워 내려지기 때문에, 두 메모리 영역의 주소가 겹치게 되는 Overflow가 발생할 수도 있게 된다.

![3heap](https://user-images.githubusercontent.com/22022393/116102636-d79e5200-a6e9-11eb-83e6-2a69e8f6457a.png)

Heap overflow
Heap이 위에서부터 주소값을 채워져 내려오다가 Stack영역을 침범하는 경우.

Stack overflow
Stack영역이 Heap을 침범하는 경우.
